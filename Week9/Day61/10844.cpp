#include <iostream>

using namespace std;

typedef long long int_64;

int_64 dp[10][101];

int main(void)
{
    int n; // 길이가 n
    cin >> n;
    // 계단 수를 생각해보면 첫번째 수에서 올라가거나 / 내려가거나 2개로 분리할 수 있음
    // 자릿수가 하나 늘어날 때마다 경우의 수가 2배씩 됨
    // 단, 9에서는 올라가는 경우의 수가 하나 봉인됨
    // 2인 경우 1~8 의 7가지 수 * 2 + 9의 1가지 수 = 17
    // 이걸 어떻게 dp로 표현할까?
    // 자릿수가 늘어날 경우 10같은 경우는 다음에 올 수가 101 하나로 고정됨... 
    // 1에서는 2가지, 0에서 , 9에서는 1가지 경우의 수로 늘기 때문에 이중배열로 선언해보자
    // dp[i][j]에서 i는 n으로 끝나는 계단수의 개수를 의미함
    // i가 0과 9가 아닐 때 dp[i][j+1] = dp[i-1][j] + dp[i+1][j]로 표현할 수 있게 됨
    // i과 0과 9인 경우에는 1에서 내려오는 경우 혹은 8에서 올라오는 경우 뿐이므로 dp[i][j+1] = dp[i+1][j] // dp[i][j+1] = dp[i-1][j]; 로 표현함
    for(int i = 1; i < 10; i++)
    {
        dp[i][1] = 1; // 한자릿수인 경우 무조건 1임 0으로 시작할 수는 없으므로 dp[0][1] 은 0
    }
    for(int i = 2; i <= n; i++)
    {
        for(int j = 0; j < 10; j++)
        {
            if(j == 0)
            {
                dp[0][i] = dp[1][i-1];
            }
            else if(j == 9)
            {
                dp[9][i] = dp[8][i-1];
            }
            else {
                dp[j][i] = dp[j-1][i-1] + dp[j+1][i-1];
                dp[j][i] = dp[j][i] % 1000000000;
            }
        }
    }
    int_64 ans = 0;
    for(int i = 0; i < 10; i++)
    {
        ans = ans + dp[i][n];
        ans = ans % 1000000000;
    }
    cout << ans << '\n';
    return 0;
}